#Simulating stock prices using Monte Carlo Simulation
#Step1: importing libraries
import numpy as np  
import pandas as pd  
from pandas_datareader import data as wb  
import matplotlib.pyplot as plt  
from scipy.stats import norm
%matplotlib inline

#Step2: Sourcing data from yahoo finance; using pandas and pandas_datareader libraries to form tabular data and read data respectively
ticker = 'MSFT' 
data = pd.DataFrame()
data[ticker] = wb.DataReader(ticker, data_source='yahoo', start='2000-1-1')['Adj Close']

#Step3: Calculating log returns by calling numpy library
log_returns = np.log(1 + data.pct_change())

#Step4: Calculating the mean and variance of the returns
u = log_returns.mean()
var = log_returns.var()

#Brownian Motion = drift + stdev*Z

#Step5: Calculating the drift and volatility
drift = u - (0.5 * var) 
stdev = log_returns.std()

#Step6: The type of drift and stdev is .series type. Hence, we must convert it to an array
np.array(drift)
np.array(stdev)

#Step7: Preparing the random variable component. It is the distance between the mean and the different values
x= np.random.rand(10,2)
Z = norm.ppf(np.random.rand(10,2)) #.ppf converts the random probabilities generated by .rand function to distances from the mean=0 

#Step8: Number of days and number of iterations
t_intervals = 1000
iterations = 10

#Step9: Calculate the returns
daily_returns = np.exp(drift.values + stdev.values * norm.ppf(np.random.rand(t_intervals, iterations)))

#Step10: Sourcing the last traded price 
S0 = data.iloc[-1]

#Step11: Creating the price_list array, which can be atmost the same size as that of daily_returns array
price_list = np.zeros_like(daily_returns)
price_list[0] = S0

#Step12: Creating a for loop to fill the price_list. It will contain a 1000*10 matrix
for t in xrange(1, t_intervals):
    price_list[t] = price_list[t - 1] * daily_returns[t]

#Step13: Graphing the iterations
plt.figure(figsize=(10,6))
plt.plot(price_list);
